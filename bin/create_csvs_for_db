#!/usr/bin/perl

#######################################################################
#
# $HeadURL$
# $Author$
# $Revision$
# $Date$
#
#######################################################################

use warnings;
use strict;

use DBI;
use Pod::Usage;
use Getopt::Long;
use Term::ReadKey;
use Carp qw(croak);
use Bio::SeqIO;
use File::Find::Rule;
use XML::LibXML;

=pod

=head1 NAME

    create_csvs_for_db

=head1 SYNOPSIS

    create_csvs_for_db --clusters /path/to/cluster/centroids.fasta --kos /path/to/kegg_ko_list --ipr_dir /path/to/dir/of/iprscan.xml --out /path/to/out_dir

=head1 DESCRIPTION

    Generates csv files from clusters, Kegg mappings (KO's) and iprscan results for database loading with 'create_florinash_db'

=head1 REQUIRED ARGUMENTS

=over 4

=item B<clusters>: Path to centroids fasta file produced by uclust, with accessions in the format SAMPLEID_gene_id

=item B<kos>: File of cluster -> ko mappings, formatted as centroid  id, kegg genes hit, KO generated by allocate_kos_to_clusters

=item B<ipr_dir>: Directory of XML formatted iprscan outputs. The parser was written for Impact XML format 1.1 (iprscan 5.5RC7 onwards)

=item B<out>: Path to output directory

=back

=head1 AUTHOR - James Abbott

Email j.abbott@imperial.ac.uk

=cut

{

    my ( $clusters, $kos, $ipr_dir, $out, $help, $man );

    GetOptions(
                'clusters=s' => \$clusters,
                'kos=s'      => \$kos,
                'ipr_dir=s'  => \$ipr_dir,
                'out=s'      => \$out,
                'man'        => \$man,
                'help'       => \$help,
              );

    croak "\nUnknown argument: @ARGV" if "@ARGV";
    pod2usage( verbose => 2 ) if ($man);
    pod2usage( verbose => 1 ) if ( $help || !$clusters || !$out );

    my %cluster_ids;

	# Parse cluster centroids, and generate primary key for tebale with $count, 
	# and store id -> $count mapping for looking up cluster ids later on...
    my $inIO = Bio::SeqIO->new( -format => 'fasta', -file => "$clusters" );
    open OUT, ">$out/Cluster.csv" or die "Could not open $out: $!";
    my $count = 0;
    while ( my $seq = $inIO->next_seq() ) {
        my $centroid = $seq->display_id();

        my $acc = sprintf( "FMGC%08d", ++$count );
        $cluster_ids{$centroid} = $count;
        print OUT "$count,$acc,$centroid," . $seq->seq(), "\n";
    }
    close OUT;

	# Parse kegg kos (generated with allocate_kos_to_clusters) - doesn't matter if this is sorted or not
    open KEGG_MAPPING, ">$out/KeggMapping.csv" or die "Error opening $out/kegg_mapping.csv: $!";
    open KOS, $kos or die "Error opening $kos:$!";
    while ( my $line = <KOS> ) {
        chomp $line;
        my ( $id, $mapping, $ko ) = split( /\t/, $line );
        print KEGG_MAPPING $cluster_ids{$id}, ",$mapping,$ko\n";
    }
    close KEGG_MAPPING;
    close KOS;

    #IPRSCAN results
    my @files = File::Find::Rule->file()->name("*.xml")->in($ipr_dir);

    open DOMAINS,    ">$out/IprscanDomains.csv"         or die "Error opening $out/IprscanDomains.csv: $!";
    open GOTERMS,    ">$out/IprscanGoTerms.csv"         or die "Error opening $out/IprscanGoTerms.csv: $!";
    open PW,         ">$out/IprscanPw.csv"              or die "Error opening $out/IprscanPw.csv: $!";
    open CL_DOMAINS, ">$out/Cluster_IprscanDomains.csv" or die "Error opening $out/Cluster_IprscanDomains.csv: $!";
    open CL_GOTERMS, ">$out/Cluster_IprscanGoTerms.csv" or die "Error opening $out/Cluster_IprscanGoTerms.csv: $!";
    open CL_PW,      ">$out/Cluster_IprscanPw.csv"      or die "Error opening $out/Cluster_IprscanPw.csv: $!";

    my $pw_id  = 0;                    # primary key for IprscanPw table...
    my $parser = XML::LibXML->new();
    foreach my $file (@files) {
        print "Processing $file....\n";
        my $doc = $parser->parse_file($file);
        my $xc  = XML::LibXML::XPathContext->new($doc);
        $xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

        foreach my $seq ( $xc->findnodes('/ipr:protein-matches/ipr:protein') ) {

            my ( %ipr_hits, %go_hits, %pw_hits, @ids );

            my $xc2 = XML::LibXML::XPathContext->new($seq);
            $xc2->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

            my $xref = $xc2->findnodes('./ipr:xref');
            foreach my $node ( $xref->get_nodelist() ) {
		# We might have multiple IDs attached to a single iprscan result, if the protein is identical
                my @atts = $node->attributes();
                foreach my $att (@atts) {
                    my $id      = $att->getValue;
                    my $orig_id = $id;

                    $id =~ s/_[0-9]+$//;
                    push @ids, $id;
                    if ( !$cluster_ids{$id} ) {
                        print "No ID map: $id (original id = $orig_id)\n";
                        print "ipr result = $file\n";
                    }
                }
            }

            foreach my $match ( $xc2->findnodes('./ipr:matches') ) {
                my $match_xc = XML::LibXML::XPathContext->new($match);
                $match_xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );
                foreach my $entry ( $match_xc->findnodes('*/ipr:signature/ipr:entry') ) {

                    my $entry_xc = XML::LibXML::XPathContext->new($entry);
                    $entry_xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

                    foreach my $go ( $entry_xc->findnodes('./ipr:go-xref') ) {

                        my $go_id = $go->findvalue('@id');
                        my %data  = ();
                        $data{'go_cat'}  = $go->findvalue('@category');
                        $data{'go_name'} = $go->findvalue('@name');
                        $go_hits{$go_id} = \%data;
                    }

                    foreach my $pw ( $entry_xc->findnodes('./ipr:pathway-xref') ) {

                        my %data  = ();
                        my $pw_id = $pw->findvalue('@id');
                        $data{'name'}    = $pw->findvalue('@name');
                        $data{'db'}      = $pw->findvalue('@db');
                        $pw_hits{$pw_id} = \%data;

                    }

                    my %data = ();
                    my $ac   = $entry->findvalue('@ac');

                    $data{'type'}  = $entry->findvalue('@type');
                    $data{'name'}  = $entry->findvalue('@name');
                    $data{'desc'}  = $entry->findvalue('@desc');
                    $ipr_hits{$ac} = \%data;
                }

                #Output results to csv file...
                foreach my $id (@ids) {    # may be mulitple ids relating to the same protein, unfortunately
                    foreach my $ipr ( sort keys(%ipr_hits) ) {
                        print DOMAINS "$ipr,"
                          . $ipr_hits{$ipr}->{'type'} . ","
                          . $ipr_hits{$ipr}->{'name'} . ","
                          . $ipr_hits{$ipr}->{'desc'} . "\n";
                        print CL_DOMAINS $cluster_ids{$id} . ",$ipr\n";
                    }

                    foreach my $go ( sort keys(%go_hits) ) {
                        print GOTERMS "$go," . $go_hits{$go}->{'go_cat'} . "," . $go_hits{$go}->{'go_name'} . "\n";
                        print CL_GOTERMS $cluster_ids{$id} . ",$go\n";
                    }

                    foreach my $pw ( sort keys(%pw_hits) ) {
                        print PW ++$pw_id, ",", $pw, ",", $pw_hits{$pw}->{'db'}, ",", $pw_hits{$pw}->{'name'}, "\n";
                        print CL_PW $cluster_ids{$id}, ",$pw\n";

                    }
                }
            }

        }

    }
    close DOMAINS;
    close GOTERMS;
    close PW;
    close CL_DOMAINS;
    close CL_GOTERMS;
    close PW;
}

