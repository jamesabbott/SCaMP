#!/usr/bin/perl

#######################################################################
#
# $HeadURL$
# $Author$
# $Revision$
# $Date$
#
#######################################################################

use warnings;
use strict;

use DBI;
use Pod::Usage;
use Getopt::Long;
use Term::ReadKey;
use Carp qw(croak);
use Bio::SeqIO;
use Bio::SearchIO;
use File::Find::Rule;
use XML::LibXML;

=pod

=head1 NAME

    create_csvs_for_db

=head1 SYNOPSIS

    create_csvs_for_db --uclust /path/to/cluster/stem --usearch /path/to/usearch_outputs --ipr_dir /path/to/dir/of/iprscan.xml --out /path/to/out_dir

=head1 DESCRIPTION

    Generates csv files from clusters, Usearch hits vs KEGG, and iprscan results for database loading with 'create_florinash_db'

=head1 REQUIRED ARGUMENTS

=over 4

=item B<uclust>: Path to uclust results, including stem of file outputs (i.e without consensus.fa or .uc suffix)

=item B<usearch>: Directory of usearch .out files from mapping vs kegg genes

=item B<ipr_dir>: Directory of XML formatted iprscan outputs. The parser was written for Impact XML format 1.1 (iprscan 5.5RC7 onwards)

=item B<out>: Path to output directory

=back

=head1 AUTHOR - James Abbott

Email j.abbott@imperial.ac.uk

=cut

{

    my ( $uclust, $usearch, $ipr_dir, $out, $help, $man );

    GetOptions(
                'uclust=s' => \$uclust,
                'usearch=s'   => \$usearch,
                'ipr_dir=s'   => \$ipr_dir,
                'out=s'       => \$out,
                'man'         => \$man,
                'help'        => \$help,
              );

    croak "\nUnknown argument: @ARGV" if "@ARGV";
    pod2usage( verbose => 2 ) if ($man);
    pod2usage( verbose => 1 ) if ( $help || !$uclust|| !$out );

    my %cluster_ids;

    parse_clusters( $out, $uclust, \%cluster_ids );
    parse_usearch( $out, $usearch, \%cluster_ids );
    parse_iprscan( $out, $ipr_dir, \%cluster_ids );

}

sub parse_clusters {

    my $out         = shift;
    my $stem        = shift;
    my $cluster_ids = shift;

	my $centroids = $stem . '.cluster.centroids.fa';
	my $uc = $stem . ".uc";
	my $sorted_uc = $stem . ".sorted.uc";

	print "\nParsing clusters...\n";
	print "====================\n";
		
	print "\n\n\tSorting output....\n";
	my $cmd = "sort -nk2 $uc > $sorted_uc";
	(system($cmd) == 0) or croak "Error sorting $uc: $!";
	
	print "\tParsing output....\n";
	my %clusters;
	open CLUST, $sorted_uc or die "Error opening $sorted_uc: $!";
	while (my @fields = split(/\t/,<CLUST>)) {
		chomp $fields[9];
		if ($fields[0] eq 'C') {
			croak "Error...cluster $fields[8] already exists...\n" if ($clusters{$fields[8]});;
			$clusters{$fields[8]}=[$fields[8]];

		} elsif ($fields[0] eq 'H') {
				my $arr = $clusters{$fields[9]};
				push @$arr, $fields[8];
				$clusters{$fields[9]} = $arr;
		}
	}
	close CLUST;

    # Parse cluster centroids, and generate primary key for tebale with $count,
    # and store id -> $count mapping for looking up cluster ids later on...
    print "\nProcessing centroids...\n";
    print "=======================\n";
    my $inIO = Bio::SeqIO->new( -format => 'fasta', -file => "$centroids" );

    open OUT, ">$out/Cluster.csv" or die "Could not open $out: $!";
    my $count = 0;
    while ( my $seq = $inIO->next_seq() ) {
        my $centroid = $seq->display_id();

        my $acc = sprintf( "FMGC%08d", ++$count );
        $cluster_ids->{$centroid} = $count;
	my $cluster = $clusters{$centroid};
	my $members = scalar(@$cluster);
        print OUT "$count,$acc,$centroid,$members\n";
    }
    close OUT;


	
}

sub parse_usearch {

    my $out         = shift;
    my $usearch     = shift;
    my $cluster_ids = shift;

    my ( %ko_mappings, %go_mappings, %brite_mappings );

    print "\nProcessing usearch results\n";
    print "==========================\n";

    print "\nLoading KEGG gene -> KO mappings...\n";

    open KO, "/data/databases/flatfiles/kegg/mirror/genes/ko/ko_genes.list" or croak "Error opening ko_genes.list: $!";
    while ( my ( $ko, $id ) = split( /\t/, <KO> ) ) {
        chomp $id;
        $ko_mappings{$id} = $ko;
    }
    close KO;

    print "Loading KEGG KO -> GO mappings...\n";
    open GO, "/data/databases/flatfiles/kegg/mirror/genes/ko/ko_go.list" or croak "Error opening ko_go.list: $!";
    while ( my ( $ko, $go ) = split( /\t/, <GO> ) ) {
        chomp $go;
        $go_mappings{$ko} = $go;
    }
    close GO;

    print "Loading KEGG KO -> BRITE mappings...\n";
    open BRITE, "/data/databases/flatfiles/kegg/mirror/genes/ko/ko_brite.list"
      or croak "Error opening ko_brite.list:$!";
    while ( my ( $ko, $brite ) = split( /\t/, <BRITE> ) ) {
        chomp $brite;
	if ($brite_mappings{$ko}) {
		$brite_mappings{$ko}=$brite_mappings{$ko} . ";$brite";
	} else {
        	$brite_mappings{$ko} = $brite;
	}
    }
    close BRITE;

    print "Loading KEGG pathway descriptions...\n";
    open KEGG, "/data/databases/flatfiles/kegg/mirror/pathway/pathway.list" or croak "Error opening pathway.list: $!";
    open PATH, ">$out/KeggPw.csv" or die "Error opening $out/KeggPw.csv: $!";
    while ( my $line = <KEGG> ) {
        next if ( $line =~ /^#/ );
        my ( $id, $des ) = split( /\t/, $line );
        chomp $des;
        print PATH $id . ',' . '"' . $des . '"' . "\n";
    }
    close KEGG;
    close PATH;

    print "\nParsing results...\n";
    my ( %kos, %samples );
    opendir RES, $usearch or die "Error opening input directory $!";
    my @files = grep /.out$/, readdir RES;
    close RES;

    open KEGG_MAPPING, ">$out/KeggUsearch.csv" or die "Error opening $out/KeggUsearch.csv: $!";
    my $kegg_id = 0;

    foreach my $file (@files) {
        print "parsing $file...\n";
        my $in = new Bio::SearchIO( -file => "$usearch/$file", -format => 'blasttable' );
        while ( my $result = $in->next_result ) {
            my ( $top_hit, $top_length );
            my $top_score = 0;
            while ( my $hit = $result->next_hit ) {
                my $top_hsp = $hit->next_hsp();
                if ( $top_hsp->length('total') > 50 && $top_hsp->percent_identity >= 80 ) {
                    if ( $top_hsp->length('total') * ( $top_hsp->bits() ) > $top_score ) {
                        $top_score  = $top_hsp->length('total') * $top_hsp->bits;
                        $top_length = $top_hsp->length('total');
                        $top_hit    = $hit->name;
                    }
                }

            }
            if ($top_hit) {
                print KEGG_MAPPING ++$kegg_id, ",", $cluster_ids->{ $result->query_name() }, ",", $top_hit, ",";
                print KEGG_MAPPING $ko_mappings{$top_hit} if ( defined( $ko_mappings{$top_hit} ) );
                print KEGG_MAPPING ",";
                print KEGG_MAPPING $brite_mappings{ $ko_mappings{$top_hit} }
                  if ( $ko_mappings{$top_hit} && $brite_mappings{ $ko_mappings{$top_hit} } );
                print KEGG_MAPPING ",";
                print KEGG_MAPPING $go_mappings{ $ko_mappings{$top_hit} }
                  if ( $ko_mappings{$top_hit} && $go_mappings{ $ko_mappings{$top_hit} } );
                print KEGG_MAPPING "\n";
            }
        }

    }

    close KEGG_MAPPING;

}

sub parse_iprscan {
    my $out         = shift;
    my $ipr_dir     = shift;
    my $cluster_ids = shift;

    print "\nParsing iprscan results....\n";
    my @files = File::Find::Rule->file()->name("*.xml")->in($ipr_dir);

    open DOMAINS, ">$out/IprscanDomains.csv" or die "Error opening $out/IprscanDomains.csv: $!";

    #open GOTERMS,    ">$out/IprscanGoTerms.csv"         or die "Error opening $out/IprscanGoTerms.csv: $!";
    open PW,         ">$out/IprscanPw.csv"              or die "Error opening $out/IprscanPw.csv: $!";
    open CL_DOMAINS, ">$out/Cluster_IprscanDomains.csv" or die "Error opening $out/Cluster_IprscanDomains.csv: $!";
    open CL_GOTERMS, ">$out/Cluster_GoTerms.csv"        or die "Error opening $out/Cluster_GoTerms.csv: $!";
    open CL_PW,      ">$out/Cluster_IprscanPw.csv"      or die "Error opening $out/Cluster_IprscanPw.csv: $!";

    my $pw_id  = 0;                    # primary key for IprscanPw table...
    my $parser = XML::LibXML->new();
    my ( %seen_domain, %seen_go, %seen_pw );

    foreach my $file (@files) {
        print "Processing $file....\n";
        my $doc = $parser->parse_file($file);
        my $xc  = XML::LibXML::XPathContext->new($doc);
        $xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

        foreach my $seq ( $xc->findnodes('/ipr:protein-matches/ipr:protein') ) {

            my ( %ipr_hits, %go_hits, %pw_hits, @ids );

            my $xc2 = XML::LibXML::XPathContext->new($seq);
            $xc2->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

            my $xref = $xc2->findnodes('./ipr:xref');
            foreach my $node ( $xref->get_nodelist() ) {

                # We might have multiple IDs attached to a single iprscan result, if the protein is identical
                my @atts = $node->attributes();
                foreach my $att (@atts) {
                    my $id      = $att->getValue;
                    my $orig_id = $id;

                    #$id =~ s/_[0-9]+$//;
                    push @ids, $id;
                    if ( !$cluster_ids->{$id} ) {
                        print "No ID map: $id (original id = $orig_id)\n";
                        print "ipr result = $file\n";
                    }
                }
            }

            foreach my $match ( $xc2->findnodes('./ipr:matches') ) {
                my $match_xc = XML::LibXML::XPathContext->new($match);
                $match_xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );
                foreach my $entry ( $match_xc->findnodes('*/ipr:signature/ipr:entry') ) {

                    my $entry_xc = XML::LibXML::XPathContext->new($entry);
                    $entry_xc->registerNs( 'ipr', 'http://www.ebi.ac.uk/interpro/resources/schemas/interproscan5' );

                    foreach my $go ( $entry_xc->findnodes('./ipr:go-xref') ) {

                        my $go_id = $go->findvalue('@id');
                        my %data  = ();
                        $data{'go_cat'}  = $go->findvalue('@category');
                        $data{'go_name'} = $go->findvalue('@name');
                        $go_hits{$go_id} = \%data;
                    }

                    foreach my $pw ( $entry_xc->findnodes('./ipr:pathway-xref') ) {

                        my %data  = ();
                        my $pw_id = $pw->findvalue('@id');
                        $data{'name'}    = $pw->findvalue('@name');
                        $data{'db'}      = $pw->findvalue('@db');
                        $pw_hits{$pw_id} = \%data;

                    }

                    my %data = ();
                    my $ac   = $entry->findvalue('@ac');

                    $data{'type'}  = $entry->findvalue('@type');
                    $data{'name'}  = $entry->findvalue('@name');
                    $data{'desc'}  = $entry->findvalue('@desc');
                    $ipr_hits{$ac} = \%data;
                }

                #Output results to csv file...
                foreach my $id (@ids) {    # may be mulitple ids relating to the same protein, unfortunately
                    foreach my $ipr ( sort keys(%ipr_hits) ) {
                        unless ( $seen_domain{$ipr} ) {
                            print DOMAINS "$ipr,"
                              . $ipr_hits{$ipr}->{'type'} . ","
                              . $ipr_hits{$ipr}->{'name'} . ","
                              . $ipr_hits{$ipr}->{'desc'} . "\n";
                            $seen_domain{$ipr}++;
                        }
                        print CL_DOMAINS $cluster_ids->{$id} . ",$ipr\n";
                    }

                    foreach my $go ( sort keys(%go_hits) ) {

                        #unless ( $seen_go{$go} ) {
                        #    print GOTERMS "$go," . $go_hits{$go}->{'go_cat'} . "," . $go_hits{$go}->{'go_name'} . "\n";
                        #    $seen_go{$go}++;
                        #}
                        print CL_GOTERMS $cluster_ids->{$id} . ",$go,IPRSCAN\n";
                    }

                    foreach my $pw ( sort keys(%pw_hits) ) {
                        unless ( $seen_pw{$pw} ) {
                            if ( $pw_hits{$pw}->{'db'} eq 'KEGG' ) {
                                my ( $path_id, $ec ) = split( /\+/, $pw );
                                print PW "$pw,", $pw_hits{$pw}->{'db'}, ",$path_id,$ec,", $pw_hits{$pw}->{'name'}, "\n";
                            }
                            else {
                                print PW "$pw,", $pw_hits{$pw}->{'db'}, ",,,", $pw_hits{$pw}->{'name'}, "\n";

                            }
                            $seen_pw{$pw}++;

                        }
                        print CL_PW $cluster_ids->{$id}, ",$pw\n";
                    }
                }
            }

        }

    }
    close DOMAINS;

    #close GOTERMS;
    close PW;
    close CL_DOMAINS;
    close CL_GOTERMS;
    close PW;
}

